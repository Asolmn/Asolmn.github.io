<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>了解一下栈结构</title>
    <url>/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><blockquote>
<p>本文部分截图来自<a href="https://www.bilibili.com/video/BV1b7411N798?p=15&spm_id_from=pageDriver">王道考研</a><br>书籍参考：[1]王晓东.数据结构（语言描述）[M].北京：电子工业出版社.2019前言</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>栈是一种特殊的表，这种表只能在表首进行插入和删除。所以表首对于栈有特殊意义，称为栈顶，表尾称为栈底，不含任何元素的栈称为空栈。可以简单的来说，栈的修改是按后进先出的原则进行，又称为后进先出（Last In First Out）表，简称LIFO表。</p>
</blockquote>
<p>假设一个栈$S$中的元素为$a(n),a(n-1),…,a(1)$，则称$a(1)$为栈底元素，$a(n)$为栈顶元素。栈中元素按照$a(1),a(2)…,a(n)$的顺序进栈，第一个进栈的是$a(1)$，接着依次往后，任何时候，出栈的都是栈顶元素$a(n)$。当$n$个不同的元素进栈，出栈元素不同排列的个数则为<br>$$<br>\frac{1}{n+1}C_{2n}^n<br>$$<br>这个公式称为卡特兰（<strong>Catalan</strong>）数</p>
<ul>
<li><code>InitStack(&amp;S)</code>：初始化栈，构造一个空栈$S$，分配内存空间。</li>
<li>StackFree(&amp;S)`：销毁栈，销毁并释放栈$S$所占用的内存空间</li>
<li><code>Push(&amp;S,x)</code>：进栈，若栈$S$未满，则将$x$加入使之成为新栈顶。</li>
<li><code>Pop(&amp;S,&amp;x)</code>：出栈，若栈$S$非空，则弹出栈顶元素，并用$x$返回。</li>
<li><code>StackTop(&amp;S,&amp;x)</code>：读入栈顶元素，若栈$S$非空，则用$x$返回栈顶元素</li>
<li><code>StackEmpty(&amp;S)</code>：判断一个栈$S$是否为空，若$S$为空，则返回<code>True</code>，否则<code>False</code></li>
</ul>
<h4 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h4><blockquote>
<p>栈是一个特殊的表，所以可以使用数组来实现栈，用一个数组data存储栈元素，栈底固定在数组的底部，即data[0]为最早的入栈元素</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<h5 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈-顺序存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">astack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> top, <span class="comment">//栈顶</span></span><br><span class="line">        maxtop; <span class="comment">// 栈空间上界</span></span><br><span class="line">    <span class="keyword">int</span> *data; <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">&#125;Astack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">astack</span> *<span class="title">Stack</span>;</span> <span class="comment">//栈指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">StackInit</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*S)); <span class="comment">// 创建一个空栈</span></span><br><span class="line">    S-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//为存储栈元素的数组分配内存空间</span></span><br><span class="line">    S-&gt;maxtop = size; <span class="comment">// 栈空间上限为size</span></span><br><span class="line">    S-&gt;top = <span class="number">-1</span>; <span class="comment">// 初始化栈顶指针</span></span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S = StackInit(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个size大小的栈，因为刚开始的时候，<code>data[0]</code>还没存放数据，所以<code>S-&gt;top</code>初始化不能等于$0$，令它等于$-1$</p>
<h5 id="栈顺序存储的基本操作"><a href="#栈顺序存储的基本操作" class="headerlink" title="栈顺序存储的基本操作"></a>栈顺序存储的基本操作</h5><p><strong>判断非空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 是否为空栈 */</span></span><br><span class="line">    <span class="keyword">return</span> S-&gt;top &lt; <span class="number">0</span>; <span class="comment">// 如果栈顶小于0，证明还没存储元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>进栈操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 进栈操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (StackFull(S))&#123;</span><br><span class="line">        <span class="comment">// 判断是否栈满</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top = S-&gt;top+<span class="number">1</span>; <span class="comment">// 栈顶加1</span></span><br><span class="line">    S-&gt;data[S-&gt;top] = x; <span class="comment">// 添加一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断栈顶指针是否已经达到了栈的最大容量，如果是返回<code>False</code>。因为入栈了一个元素，所以栈顶指针加1，再令当前栈顶指针的位置等于插入元素$x$。</p>
<p><strong>出栈操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 出栈操作 */</span></span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(S))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = S-&gt;data[S-&gt;top]; <span class="comment">//返回出栈的元素</span></span><br><span class="line">    S-&gt;top = S-&gt;top<span class="number">-1</span>; <span class="comment">// 栈顶减一</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令栈顶指针<code>top</code>减去一位，使得逻辑上进行一个出栈操作，但实际数据还是遗留在内存中。</p>
<p><strong>读栈顶元素</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackTop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 读取栈顶 */</span></span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;data[S-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组是动态分配的，所以需要写一个释放内存的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackFree</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印栈</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPrint</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 打印栈 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=S-&gt;top; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 因为栈后进先出，所以要从栈顶开始打印，一直到栈底</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,S-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同时使用过多个栈的情况，为了不会栈溢出，通常要给栈分配一个较大的栈空间，但是各个栈在算法运行中，所使用的最大空间很难估计。所以可以使用共享栈来提高栈空间的利用率。</p>
<p>例如两个栈使用同一个数组<code>data[0:n]</code>，那么利用栈底不变的特性，一个栈底设为0，另一个栈底设为n，分别各自往数组中间延申。这样每一个栈最大的可用空间为$\frac{n}{2}$。</p>
<h4 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h4><blockquote>
<p>如果要用到多个栈的时候，可以使用链表作为栈的存储结构，也就是栈的链式存储，就是用指针来实现栈。这样方式使栈有着动态大小，这种实现方式也被称为链栈</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<h5 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈-链式存储</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">snode</span>&#123;</span> <span class="comment">// 栈结构</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 栈元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snode</span> *<span class="title">next</span>;</span> <span class="comment">// 下一结点指针</span></span><br><span class="line">&#125;StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> StackNode *SLink; <span class="comment">// 栈结点指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lstack</span>&#123;</span> <span class="comment">// 栈结构</span></span><br><span class="line">    SLink top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;Lstack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Lstack *Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">SLink <span class="title">NewStackNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 创建新结点 */</span></span><br><span class="line">    <span class="keyword">return</span> (SLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">StackInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化栈 */</span></span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*S));</span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>; <span class="comment">// top置为空指针</span></span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S = StackInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testStack();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先创建一个栈结点的类型，<code>data</code>存储栈元素，<code>next</code>指向下一个结点的指针。使用<code>typedef</code>创建一个<code>snode</code>类型的栈结点指针类型<code>SLink</code>。</p>
<p>再创建一个链栈<code>Stack</code>，其中结构只有一个栈顶指针，其指针的类型是栈结点指针类型<code>SLink</code>。</p>
<h5 id="栈链式存储的基本操作"><a href="#栈链式存储的基本操作" class="headerlink" title="栈链式存储的基本操作"></a>栈链式存储的基本操作</h5><p><strong>判断非空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 判断释放为空栈 */</span></span><br><span class="line">    <span class="keyword">return</span> S-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进栈操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack S, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    SLink p = NewStackNode(); <span class="comment">// 申请一个结点的内存空间</span></span><br><span class="line">    p-&gt;data = x; <span class="comment">// 将栈元素存入</span></span><br><span class="line">    p-&gt;next = S-&gt;top; <span class="comment">// 将新结点的下一个结点指针置空</span></span><br><span class="line">    S-&gt;top = p; <span class="comment">// 栈顶结点下一个为p，使p为新的栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为新结点申请一块内存空间，同时类型设置为栈结点指针类型，将元素x存入<code>data</code>中，将新结点的下一个结点置为top的下一个结点。因为top的下一个结点是NULL，所以此时结点p的下一个结点也为NULL。这时结点p为栈的栈顶。</p>
<p><strong>出栈操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 出栈操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))&#123;</span><br><span class="line">        <span class="comment">// 判断栈是否为空栈</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = S-&gt;top-&gt;data; <span class="comment">// 返回出栈元素</span></span><br><span class="line">    SLink p = S-&gt;top; <span class="comment">// 另p等于栈顶指针</span></span><br><span class="line">    S-&gt;top = p-&gt;next; <span class="comment">// 将栈顶指针top，指向p的下一个结点。</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放p</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设栈内结点为$k-&gt;q-&gt;s-&gt;Null$，这时执行出栈操作，这时候的栈顶为$s$，定义一个变量$x$，另它等于栈顶的<code>data</code>，将出栈元素赋值给x，再函数的结尾处返回。定义一个栈指针类型的结点$p$，另它等于栈顶，所以这个时候栈内就变成这样$k-&gt;q-&gt;p-&gt;Null$。将栈顶指向$p$的下一个结点，也就是$Null$,$k-&gt;q-&gt;NULL$，最后将$p$占用的结点内存释放。</p>
<p><strong>读栈顶元素</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackTop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 读取栈顶元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印栈</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackPrint</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 打印栈 */</span></span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))&#123;</span><br><span class="line">        <span class="comment">// 判断非空</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SLink p = NewStackNode(); <span class="comment">// 创建一个结点</span></span><br><span class="line">    p = S-&gt;top; <span class="comment">// 令p等于栈顶结点</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p-&gt;data); <span class="comment">// </span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>关于线性表的点点滴滴</title>
    <url>/2021/08/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><blockquote>
<p>本文部分截图来自<a href="https://www.bilibili.com/video/BV1b7411N798?p=15&spm_id_from=pageDriver">王道考研</a><br>书籍参考：[1]王晓东.数据结构（语言描述）[M].北京：电子工业出版社.2019前言</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>线性表是一种非常灵便的结构，可以根据需要改变的表的长度，也可以在表中任何位置对元素进行访问、插入、删除等操作。还可以将多个表连接成为一个表，也可以对一个表进行拆分成多个表。</p>
</blockquote>
<p>线性表的定义，是具有相同数据类型的$n(n \geq 0)$个数据元素组成的<em><strong>有限序列</strong></em>，其中元素$n$的个数定义为表的长度。当$n=0$时，线性表是一个空表，当$n \geq 1$时，称元素$a(k)$位于该表的第$k$个位置。若用L命名线性表，则其一般表示为</p>
<p>$$<br>L=(a_1,a_2,…..,a_i,a_{i+1},…..,a_n)<br>$$</p>
<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426180455034.png" alt="image-20210426180455034"></p>
<p>除此之外，还要定义一些关于线性表的运算，将这一个数学模型成为一个抽象数据<em><strong>List</strong></em>。用$x$表示表中的一个元素，$k$表示元素在表中的位置。</p>
<ul>
<li><p><code>InitList(&amp;L)</code>：初始化表，创建一个新的线性表$L$，分配内存空间</p>
</li>
<li><p><code>Destroy(&amp;L)</code>：销毁线性表，释放$L$所占的内存空间</p>
</li>
<li><p><code>ListEmpty(&amp;L)</code> ：测试表$L$是否为空</p>
</li>
<li><p><code>ListLength</code>：表$L$的长度</p>
</li>
<li><p><code>ListLocate(&amp;x,&amp;L)</code>：元素$x$在表中$L$的位置，如果$x$在表中重复出现，返回最前面的</p>
</li>
<li><p><code>ListRetrieve(&amp;k,&amp;L)</code>：返回$L$中的$k$处位置的元素</p>
</li>
<li><p><code>ListInsert(&amp;k,&amp;x,&amp;L)</code>：在表$L$的k处位置插入元素$x$，将原来占据该位置的元素及其后面都向后推一个位置</p>
</li>
<li><p><code>ListDelete(&amp;k,&amp;L)</code>：将表$L$的$k$处位置的元素删除，并返回删除的元素。</p>
</li>
<li><p><code>PrintList(&amp;L)</code>：将表$L$中的所有元素按照位置顺序打印输出</p>
</li>
</ul>
<h4 id="顺序表（数组实现）"><a href="#顺序表（数组实现）" class="headerlink" title="顺序表（数组实现）"></a>顺序表（数组实现）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来实现</p>
</blockquote>
<p>这种方法，容易实现对表的遍历，在表的尾部插入一个元素很容易。但是如果要在表的头和中间的位置插入一个新元素。那么这个新元素插入位置的后面所有元素都要后移一位，为空出位置，存放新元素。删除以是如此，如果删除的元素不是表的最后一位，那么被删除元素后面的所有元素，都要往前移动一位，填补空缺。</p>
<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426180536932.png" alt="image-20210426180536932"></p>
<ul>
<li><strong>代码实现</strong></li>
</ul>
<h5 id="顺序表的实现-静态分配"><a href="#顺序表的实现-静态分配" class="headerlink" title="顺序表的实现-静态分配"></a>顺序表的实现-静态分配</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个表的结构，ElemType在数据结构表示，任何一种数据类型，并无实际的此类型</span></span><br><span class="line"><span class="comment">// 如果是int类型，将ElemType改为int即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10 <span class="comment">// 定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize]; <span class="comment">// 用静态的数组存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;SqList; <span class="comment">//顺序表的类型定义（静态分配方式）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现代码</span></span><br><span class="line"><span class="comment">// 顺序表-静态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10  <span class="comment">// 定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表的类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize]; <span class="comment">// 用静态的数组存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 表的当前长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SqList *List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化一个数组 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L-&gt;data[i]=<span class="number">0</span>;  <span class="comment">// 将所有数据元素设置为默认初始值 </span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426181501387.png" alt="image-20210426181501387"></p>
<p>在<code>IinitList</code>初始化表的函数中，用了一个<code>for</code>函数对每一个元素进行了初始化，如果不怎么会给内存遗留的脏数据污染（如下图）。</p>
<p><img src="https://i.loli.net/2021/03/07/ie81JYGxSalfHz5.png" alt="image-20210307211124565"></p>
<p>静态分配的精髓就是再<code>data[MaxSize]</code>，直接设置一个固定的长度的数组。但是有非常大的缺陷，如果存满的只能放弃这个数组，因为静态数组的表长确定后创建是不能更改的。</p>
<h5 id="顺序表的实现-动态分配"><a href="#顺序表的实现-动态分配" class="headerlink" title="顺序表的实现-动态分配"></a>顺序表的实现-动态分配</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10 <span class="comment">// 顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data; <span class="comment">//动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> maxsize; <span class="comment">// 顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>

<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426181358975.png" alt="image-20210426181358975"></p>
<p>c语言实现顺序表的动态分配，主要依靠<code>malloc</code> <code>free</code>两个函数，一个进行动态申请内存空间，一个进行释放内存空间，包含在头文件<code>&lt;stdlib.h&gt;</code>头文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">L-&gt;data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize); <span class="comment">// 申请空间</span></span><br><span class="line"><span class="built_in">free</span>(L); <span class="comment">//释放空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> maxsize;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> SeqList *SList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化一个动态分配数组 */</span></span><br><span class="line">    L-&gt;data=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 申请InitSize值的内存空间</span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;maxsize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SList L,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 增加动态数组的长度 */</span></span><br><span class="line">    <span class="keyword">int</span> *p = L-&gt;data; <span class="comment">//先将原先的数组保存</span></span><br><span class="line">    L-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L-&gt;maxsize+len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 申请加上len之后的内存空间大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L-&gt;length; i++)&#123;</span><br><span class="line">        L-&gt;data[i] = p[i]; <span class="comment">//将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;maxsize = L-&gt;maxsize+len; <span class="comment">// 顺序表最大长度添加len</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFree</span><span class="params">(SList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 释放表 */</span></span><br><span class="line">    <span class="built_in">free</span>(L-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//动态分配</span></span><br><span class="line">    SList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不管是动态分配还是静态分配，都具有一些相同的特性</p>
<ul>
<li>随机访问，可以在$O(1)$时间内找到第i个元素</li>
<li>存储密度高，每一个节点只存储数据元素本身</li>
</ul>
<h5 id="关于顺序表的基本操作"><a href="#关于顺序表的基本操作" class="headerlink" title="关于顺序表的基本操作"></a>关于顺序表的基本操作</h5><ul>
<li><strong>代码实现</strong></li>
</ul>
<p>表的类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alist</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 表长</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize; <span class="comment">// 定义数组长度</span></span><br><span class="line">    <span class="keyword">int</span> curr; <span class="comment">//当前位置</span></span><br><span class="line">    <span class="keyword">int</span> *table; <span class="comment">//存放数据元素的数组</span></span><br><span class="line">&#125;Alist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Alist *List;</span><br></pre></td></tr></table></figure>

<p><strong>初始化size大小的表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">ListInit</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化表 */</span></span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*L)); <span class="comment">//为表L申请一块内存空间</span></span><br><span class="line">    L-&gt;table = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 为表L中存放数据的数组申请一块内存空间</span></span><br><span class="line">    L-&gt;MaxSize = size;</span><br><span class="line">    L-&gt;n = <span class="number">0</span>; <span class="comment">// 因为是动态数组，所以先另表长为0</span></span><br><span class="line">    <span class="keyword">return</span> L; <span class="comment">//返回表L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试表L是否为空</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 测试是否为空 */</span></span><br><span class="line">    <span class="keyword">return</span> L-&gt;n == <span class="number">0</span>; <span class="comment">//如果表L的n等于0，代表表当前长度为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>释放表L的所申请的内存空间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListFree</span><span class="params">(List L)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(L-&gt;table);</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在表L的k位置处插入元素x</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x, List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 表中插入元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">1</span> || k&gt;L-&gt;n+<span class="number">1</span>)&#123;</span><br><span class="line">    	<span class="comment">// 如果插入的位置小于1或者大于表当前长度,返回false</span></span><br><span class="line">        ListFree(L);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;n &gt;= L-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="comment">// 如果插入的位置大于表的最大长度,返回false</span></span><br><span class="line">        ListFree(L);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=L-&gt;n; j&gt;=k; j--)&#123;</span><br><span class="line">         <span class="comment">// 如果j大于k，那么将k以及后面的元素后移</span></span><br><span class="line">        L-&gt;table[j] = L-&gt;table[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;table[k<span class="number">-1</span>] = x; <span class="comment">// 在k位置存入x</span></span><br><span class="line">    L-&gt;n++; <span class="comment">// 表的当前长度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426211830867.png" alt="image-20210426211830867"></p>
<p><strong>删除表中k处的元素</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(<span class="keyword">int</span> k, List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 删除k处的元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">1</span> || k&gt;L-&gt;n) </span><br><span class="line">        <span class="comment">// 如果删除的位置小于1或者大于表当前长度,返回false</span></span><br><span class="line">        ListFree(L);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = L-&gt;table[k<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=k; i&lt;L-&gt;n; i++)&#123;</span><br><span class="line">        <span class="comment">// 将所有的值往前移一位</span></span><br><span class="line">        L-&gt;table[i<span class="number">-1</span>] = L-&gt;table[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;n--; <span class="comment">// 表长减一</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://asolmn-blog-figure-bed.oss-cn-shenzhen.aliyuncs.com/typroa/image-20210426212041881.png" alt="image-20210426212041881"></p>
<p><em><strong>元素x在表中的位置（按值查找）</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLocate</span><span class="params">(<span class="keyword">int</span> x, List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 元素x在表中的位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;L-&gt;n; i++)&#123;</span><br><span class="line">        <span class="comment">//循环表</span></span><br><span class="line">        <span class="keyword">if</span> (L-&gt;table[i] == x)&#123;</span><br><span class="line">            <span class="comment">// 如果第i位的元素，等于x，证明x在i位</span></span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">// 因为表是从0开始，所以返回位置的时候，要加一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表中k处的元素（按位查找）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListRetrieve</span><span class="params">(<span class="keyword">int</span> k, List L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 返回表中k处位置的元素 */</span></span><br><span class="line">    <span class="keyword">if</span> (k&lt;<span class="number">1</span> || k&gt;L-&gt;n)&#123;</span><br><span class="line">        <span class="comment">// 如果调用的函数时，k的参数是小于1，或者大于表长的，则退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;table[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="部分表操作的时空复杂度"><a href="#部分表操作的时空复杂度" class="headerlink" title="部分表操作的时空复杂度"></a>部分表操作的时空复杂度</h5><ul>
<li>插入的时空复杂度</li>
</ul>
<p>如果插入的地方，为表尾，那么这是最好的情况，时间复杂度为$O(1)$。最坏情况下需要$O(n)$的时间。因为插入的位置可以是表的任意位置，所以需要分析一下平均时间复杂度。设在长度为$n$的表中进行插入，那么所需元素移动次数的平均值为$E_{IN}(n)$。在表中第$k$个位置插入元素x需要移动数组元素$n-k$次。所以<br>$$<br>E_{IN}(n)=\sum_{k=0}^nP_k(n-k)<br>$$<br>$P_k$表示在表中第$k$个位置插入元素的概率，假设在表中任何合法位置插入元素的机会是均等的，则<br>$$<br>P_0=P_1=…=P_n=\frac{1}{n+1}<br>$$<br>那么在同等概率下<br>$$<br>E_{IN}(n)=\sum_{k=0}^nP_k(n-k)=\sum_{k=0}^n\frac{n-k}{n+1}=\frac{n}{2}<br>$$<br>因为使用<strong>大n表示法</strong>，系数可以忽略，所以平均时间复杂度为<br>$$<br>O(n)<br>$$</p>
<ul>
<li>删除的时空复杂度</li>
</ul>
<p>与插入一样，设在长度为$n$的表中删除一个元素，所需要元素移动次数的平均值为$E_{DE}(n)$。删除表中第$k$个位置上的元素移动次数为$n-k$次。所以<br>$$<br>E_{DE}(n)=\sum_{k=0}^nQ_k(n-k)<br>$$<br>$Q_k$表示在第$k$个位置删除元素的概率，在等概率删除的情况下<br>$$<br>Q_1=Q_2=…=Q_n=\frac{1}{n}<br>$$<br>所以可知<br>$$<br>E_{DE}(n)=\sum_{k=0}^nQ_k(n-k)=\sum_{k=0}^n\frac{n-k}{n}=\frac{n-1}{2}<br>$$<br>同样因为是<strong>大n表示法</strong>，所以平均时间复杂度为<br>$$<br>O(n)<br>$$</p>
<h4 id="链表-单链表"><a href="#链表-单链表" class="headerlink" title="链表-单链表"></a>链表-单链表</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>单链表是一种链式存储，由一个个节点构成。每一个节点除了存放数据元素外，还要存放指向下一个节点的指针，用指针依次串联起来。</p>
</blockquote>
<p>这种方法不需要大片连续的存储空间，改变容量方便。插入和删除运算时，不在需要移动元素来移动或者填补空缺。但缺点就是因为每一个节点中设置了指针来表示元素之间的逻辑关系，所以增加了一定的空间开销，同时不可以在随机存取。如果表是$ a(1),a(2),(3)….a(n) $，那么元素$a(k)$的指针应指含有元素$a(k+1)$的单元。</p>
<ul>
<li><strong>代码实现</strong></li>
</ul>
<h5 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">// 每一个节点存放一个数据类型 称为数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针指向下一个节点 称为指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>

<p>增加一个新的节点，在内存中申请一个节点所需空间，并用指针p指向这个节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span></span><br><span class="line">LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br></pre></td></tr></table></figure>

<p>表示一个单链表时，只需要声明一个头指针L，指向单链表的下一个指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两种写法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span></span><br><span class="line">LNode * L;</span><br><span class="line">LinkList L;</span><br><span class="line"><span class="comment">// 两种定义方法效果是一样的，用LinkList可读性好一些</span></span><br></pre></td></tr></table></figure>

<h5 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表-代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> <span class="comment">// 定义单链表节点类型</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//每一个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode, *LinkList; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化单链表 */</span></span><br><span class="line">    L = <span class="literal">NULL</span>; <span class="comment">// 空表暂时没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 测试不带头节点的单链表 */</span></span><br><span class="line">    LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line">    InitList(L); <span class="comment">//初始化一个空表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	testLink();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另<code>L=NULL</code>，和之前顺序表的初始化一样，也是为了除去内存遗留的脏数据</p>
<h5 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> <span class="comment">// 定义单链表节点类型</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//每一个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> LNode *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitHeadList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化带头节点的单链表 */</span></span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头节点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">// 如果L分配之后，还是为NULL，代表内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头节点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testHeadLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 测试带头节点的单链表 */</span></span><br><span class="line">    LinkList L;</span><br><span class="line">    InitHeadList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// testLink();</span></span><br><span class="line">    testHeadLink();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中不带头节点的话，头指针指向的下一个元素存储数据，而带头节点则是头节点是不存储数据的，头节点的下一节点才存储。不带头节点写代码更加麻烦，对第一个数据节点和后续的节点都需要不同的代码逻辑，对空表和非空表的处理也不相同，所以大多数情况，还是使用带头节点的单链表。</p>
<h5 id="关于单链表的基本操作"><a href="#关于单链表的基本操作" class="headerlink" title="关于单链表的基本操作"></a>关于单链表的基本操作</h5><p>（除了特别声明，默认操作的都是带头节点的单链表）</p>
<ul>
<li><strong>代码实现</strong></li>
</ul>
<p>表的类型定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> <span class="comment">// 定义单链表节点类型</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//每一个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode; </span><br></pre></td></tr></table></figure>

<p><strong>单链表的初始化</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitHeadList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化带头节点的单链表 */</span></span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头节点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">// 如果L分配之后，还是为NULL，代表内存不足分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头节点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按位序插入（在第i位插入元素e）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkInsert</span><span class="params">(LinkList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i&lt;<span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p; <span class="comment">// 指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">// 当前p指向的是第几个节点</span></span><br><span class="line">    p = L; <span class="comment">// L指向头节点，头节点是第0个节点</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 循环找到第i-1个节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// i的值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">//s的next指向原先第i-1节点的下一个节点</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将节点s连接到p</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义一个指针<code>p</code>，用于指向当前的节点，定义一个变量<code>j</code>用于表示<code>p</code>是第几个节点。然后在初始化中的头节点<code>L</code>等于<code>p</code>。开始进行循环，将<code>p</code>扫描节点依次后移，直至不满足循环条件，这时指针<code>p</code>就为第<code>i-1</code>个节点，然后定义一个新的节点<code>s</code>，然后<code>s</code>的<code>next</code>指向原先第<code>i-1</code>节点的下一个节点（**如果是一条从头节点开始的全新单链表，那么<code>p</code>的<code>next</code>是<code>NULL</code>，为了考虑到插入的情况，可能是已经前后都含有数据的单链表，所以<code>s</code>的<code>next</code>不能直接设置为<code>NULL</code>，必须设置为<code>p</code>节点的<code>next</code>**），使第<code>i-1</code>个节点的<code>next</code>指向s。</p>
<p><strong>指定节点的后插操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*后插操作：在p节点之后插入元素e */</span></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 分配内存失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e; <span class="comment">// 用节点s保存数据e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s; <span class="comment">//将节点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有什么可以说的，就是把s的下一个指向等于p的下一个指向，再让p的下一个指向等于节点s。可以扩展一下的就是，可以将后插操作的函数应用到位序插入中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkInsert</span><span class="params">(LinkList L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i&lt;<span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p; <span class="comment">// 指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">// 当前p指向的是第几个节点</span></span><br><span class="line">    p = L; <span class="comment">// L指向头节点，头节点是第0个节点</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 循环找到第i-1个节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    InsertNextNode(p, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定节点的前插操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 在节点p之前插入元素e */</span></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">//新节点s连接到p之后</span></span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">// 对p节点和s节点的数据元素进行替换</span></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现方式可以有两种，一种是传入一个单链表L，然后进行遍历，时间复杂度为$O(n)$。一种将新节点放在指定节点之后，然后对新节点和指定节点的数据元素进行替换，使得逻辑上达到了前插操作，同时将时间复杂度变成了$O(1)$。</p>
<p><strong>按位序删除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListHeadDelete</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p; <span class="comment">// 指针p指向当前扫到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">// 当前p指向的是第几个节点</span></span><br><span class="line">    p = L; <span class="comment">// L指向头节点</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 另p等于i-1个节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// i-1个节点后没有节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">// 另q指向被删除节点</span></span><br><span class="line">    <span class="keyword">int</span> e = q-&gt;data; <span class="comment">//e为返回元素的值</span></span><br><span class="line">    p-&gt;next=q-&gt;next; <span class="comment">// 将*q从链中剔除</span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放节点存储空间</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定节点的删除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定的节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">// 令q指向*p的后继节点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">//和后继节点交换数据域，此时p就相当于变成了逻辑意义上的下一个节点</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// 再将p的下一个链接到q的下一个</span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">//释放q</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这于指定节点的插入，是同样的道理，依旧是运用了数据域内容的交换，实现了逻辑意义上的删除，同时时间复杂度为$O(1)$</p>
<p><strong>按位查找</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">        <span class="comment">// 循环找到第i个节点，上面的操作和插入一样</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本与按位插入是一样的原理，只不过按位插入是循环到底<strong>i-1</strong>个节点，查找是循环到第<strong>i</strong>个节点。如果查找的节点刚为第一个的话，那么时间复杂度为$O(1)$，平均时间复杂度为$O(n)$。</p>
<p><strong>按值查找</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 按值查找 */</span></span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">//令p等于头指针的下一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data !=e)&#123;</span><br><span class="line">        <span class="comment">// 如果p的数据元素不等于查找值，继续下一个节点，直到满足</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它是依次往后扫描寻找，当e再第n个位置的时候，那么就循环了n次，所以它的平均时间复杂度为$O(1)$。</p>
<p><strong>单链表的长度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为单链表不具备随机访问的特性，是依次查询，所以它的平均时间复杂度为$O(1)$。</p>
<h5 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h5><p>如果有很多个数据元素，要把它们存入到一个单链表中。有两种方法可以实现，一种是尾插法，一种是头插法。</p>
<ul>
<li>初始化一个单链表，每次取一个元素，插入到表尾/表头</li>
</ul>
<p><strong>尾插法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_Tailnsert</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 尾插法 */</span></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">// 设置要插入的数据</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 初始化空表</span></span><br><span class="line">    LNode *s,*r=L; <span class="comment">// r为表为指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">// 输入节点的值</span></span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//在r节点之后插入元素s</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s; <span class="comment">// 保持r永远是最后一个指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 表尾指针指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> L; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度为$O(n)$</p>
<p><strong>头插法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建头节点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始化为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next; <span class="comment">//将新节点的指针为头节点的下一个</span></span><br><span class="line">        L-&gt;next = s; <span class="comment">// 令头节点的下一个变成新插入的节点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链表-双链表"><a href="#链表-双链表" class="headerlink" title="链表-双链表"></a>链表-双链表</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>单链表中，从表的任一节点出发，都可以找到其前驱结点，但需要$O(n)$的时间。那么可以在链表的每一个结点中设置两个指针，一个指向后继结点，另一个指向前驱结点，称为双链表</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<h5 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span> <span class="comment">// 定义双链表结点类型</span></span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span> <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure>

<h5 id="带头节点的双链表"><a href="#带头节点的双链表" class="headerlink" title="带头节点的双链表"></a>带头节点的双链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>   </span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinklist</span><span class="params">(DLinklist L)</span></span>&#123;</span><br><span class="line">    L=(DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>; <span class="comment">// 头节点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头节点之后的结点暂时指向空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDLinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinklist(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testDLinklist();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是在单链表的基础上，多了一个前驱指针。用来指向上一个结点，剩下基本一样。要注意的是，头结点因为是第一个结点，所它的前驱指针永远是指向NULL的。</p>
<h5 id="关于双链表的基本操作"><a href="#关于双链表的基本操作" class="headerlink" title="关于双链表的基本操作"></a>关于双链表的基本操作</h5><p><strong>后插操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next=p-&gt;next; <span class="comment">// 令p的后继结点等于s的后继结点</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断是否为表尾，如果是表尾，那么p的下一结点是NULL</span></span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">// 令p后继结点的前驱结点等s</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = p; <span class="comment">// s的前驱结点为p</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// p的后继结点为s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如p结点的下一结点为k，这时要在p后面插入结点s。首先将p的下一个结点，也就是k，变成s的下一结点。在令k的前驱结点指向s，s的前驱结点指向p，p的下一个结点指向s。这就完成了在原先的p和k中间位置插入了结点s。</p>
<p><strong>删除操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 删除p结点的后继结点 */</span></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// 验证非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q = p-&gt;next; <span class="comment">// 找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// p没有后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// 令p的后继结点等于q的后继结点</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next!=<span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">// 判断q是不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// q的后继结点的前驱结点等于p</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁一个双链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteDLinklist</span><span class="params">(DLinklist L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 销毁一个双链表 */</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != NUll)&#123;</span><br><span class="line">        DeleteDLinklist(L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintDLinklist</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 遍历一个双链表 */</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没啥逻辑可说的，就是给定一个结点，然后对结点进行判断是否为NULL，满足循环条件进入循环，打印结点数据，然后将p指向给定结点的下一个结点，时间复杂度为$O(n)$</p>
<h4 id="链表-循环链表"><a href="#链表-循环链表" class="headerlink" title="链表-循环链表"></a>链表-循环链表</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>单链表最后一个结点的指针为空指针，循环链表就是将这个空指针指向了头结点。使整个链表形成了一个环，首尾相接。</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<h5 id="循环单链表的实现"><a href="#循环单链表的实现" class="headerlink" title="循环单链表的实现"></a>循环单链表的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> <span class="comment">// 定义一个单链表结点类型</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化一个循环单链表 */</span></span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = L; <span class="comment">// 将头节点的后继结点指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="循环双链表的实现"><a href="#循环双链表的实现" class="headerlink" title="循环双链表的实现"></a>循环双链表的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化循环链表 */</span></span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;prior = L; <span class="comment">// 头结点的前驱结点指向头结点</span></span><br><span class="line">    L-&gt;next = L; <span class="comment">// 头结点的后继结点指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链表-静态链表"><a href="#链表-静态链表" class="headerlink" title="链表-静态链表"></a>链表-静态链表</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><blockquote>
<p>设置一个游标，游标是数组中指示数组单元地址的下标值。它指示表中下一个元素在数组中的存储地址（数组下标）。虽然是用数组的方式存储表中的元素，但是插入和删除操作，并不需要移动表中元素，只需要修改游标。</p>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<h5 id="静态链表的实现"><a href="#静态链表的实现" class="headerlink" title="静态链表的实现"></a>静态链表的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10 <span class="comment">// 静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">// 存储的数据元素</span></span><br><span class="line">    <span class="keyword">int</span> next; <span class="comment">// 下一个元素的数组下标</span></span><br><span class="line">&#125;SNode, SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitSLinkList</span><span class="params">(SLinkList L)</span></span>&#123;</span><br><span class="line">    L = (SNode *)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(SNode)); <span class="comment">// 申请一片地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L[i].data = <span class="number">0</span>; <span class="comment">// 初始化每一个数组元素</span></span><br><span class="line">        L[i].next = i+<span class="number">1</span>; <span class="comment">//初始化每一个游标</span></span><br><span class="line">    &#125;</span><br><span class="line">    L[MaxSize<span class="number">-1</span>].next = <span class="number">-1</span>; <span class="comment">// 设置最后一个游标为-1代表表尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SLinkList L;</span><br><span class="line">    InitSLinkList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    testSLinkList();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>表</tag>
      </tags>
  </entry>
</search>
